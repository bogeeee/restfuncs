

export type CSRFProtectionMode = "preflight" | "corsReadToken" | "csrfToken"

export type SecurityPropertiesOfHttpRequest = {
    httpMethod: string,
    /**
     * The / your ServerSession's method name that's about to be called
     */
    serviceMethodName: string,
    /**
     * Computed origin
     * @see getOrigin
     */
    origin?: string,
    /**
     * Computed destination
     * @see getDestination
     */
    destination?: string,

    /**
     * Computed result from Util.js/browserMightHaveSecurityIssuseWithCrossOriginRequests function
     */
    browserMightHaveSecurityIssuseWithCrossOriginRequests: Boolean;

    csrfProtectionMode?: CSRFProtectionMode
    corsReadToken?: string,
    csrfToken?: string,

    /**
     * We are sure that the client proved to make a successful http read and present the result while the call had these security properties.
     * Used for socket connection.
     */
    readWasProven?: boolean

    /**
     * Computed result from couldBeSimpleRequest function
     */
    couldBeSimpleRequest?: boolean
};

/**
 * The info that's needed  to set up a socket connection
 */
export type WelcomeInfo = {
    classId: string,
    /**
     * Undefined, if the server does not support engine.io
     */
    engineIoPath?: string
};

export interface IServerSession {
    /**
     * The client needs to know some things, before creating the socket connection
     */
    getWelcomeInfo(): WelcomeInfo;

    getCookieSession(encryptedQuestion: ServerPrivateBox<GetCookieSession_question>): ServerPrivateBox<GetCookieSession_answer>;
    getHttpSecurityProperties(encryptedQuestion: ServerPrivateBox<GetHttpSecurityProperties_question>): ServerPrivateBox<GetHttpSecurityProperties_answer>;
    updateCookieSession(encryptedCookieSessionUpdate: ServerPrivateBox<CookieSessionUpdate>, alsoReturnNewSession: ServerPrivateBox<GetCookieSession_question>) : Promise<ServerPrivateBox<GetCookieSession_answer>>;
}

export interface CookieSession extends Record<string, unknown> {
    id: string
    version: number

    /**
     * Branch protection salt. We safe and check this also in the SessionValidator
     * Because the commit to the SessionValidator does not happen at instant but before the next call, an attacker could use 2 socket connections and create 2 (/multiple) branches of CookieSessions with different content but (each time) the same version number.
     * <p>
     * More detail: To create such branching, one would have 2 socket connections, call a session-changing method, get the returned CookieSessionUpdate token and http-call the updateCookieSession() method with it **simultaneously**
     * Should be possible in a browser (cross-site attacking scenario, when allowed for a subset of ServerSessions) and no problem with a non-browser client.
     * </p>
     */
    bpSalt: string

    /**
     * To allow for a more stupid SessionValidator that just stores [id]_[version]_[bpSalt] entry strings
     */
    previousBpSalt?: string

    commandDestruction?:boolean
}

export type Socket_Client2ServerMessage = {
    type: "methodCall" | "getVersion" | "updateHttpSecurityProperties" | "setCookieSession"
    payload: Socket_MethodCall | unknown
}

export type Socket_MethodCall = {
    /**
     * Generated by the client
     */
    callId: number

    serverSessionClassId?: string

    methodName: string,
    args: unknown[]
}

export type Socket_Server2ClientMessage = {
    type: "init" | "methodCallResult" | "getVersion"
    payload: Socket_Server2ClientInit | Socket_MethodCallResult | unknown
}

export type Socket_MethodCallResult = {
    /**
     * Generated by the client
     */
    callId: number

    result?: unknown

    /**
     * Behaves as close as possible to the http api
     */
    status: 200 | 500 | 550 | "needsHttpSecurityProperties" | "needsCookieSession" | "doCookieSessionUpdate" | "dropped_CookieSessionIsOutdated"

    /**
     * If a CommunicationError was thrown, then that code
     */
    httpStatusCode?: number

    /**
     * If an error occurred
     */
    error?: object

    /**
     * If this is needed to proceed the call
     */
    needsHttpSecurityProperties?: {
        question: ServerPrivateBox<GetHttpSecurityProperties_question>
        /**
         * Hint for the client: The ServerSessionClass id or the security group id for which the answer is valid.
         */
        syncKey: string
    }

    /**
     * Request the cookie-session from the server by http
     */
    needsInitializedCookieSession?: ServerPrivateBox<GetCookieSession_question>

    /**
     * Commands to update the cookieSession via http (so it really gets stored in the cookie)
     */
    doCookieSessionUpdate?: ServerPrivateBox<CookieSessionUpdate>


}

export type Socket_Server2ClientInit = {
    cookieSessionRequest: ServerPrivateBox<GetCookieSession_question>
}


/**
 * Question from the websocket connection
 */
export type GetHttpSecurityProperties_question = {
    serverSocketConnectionId: string
    serverSessionClassId: string,
}

export type GetHttpSecurityProperties_answer = {
    question: GetHttpSecurityProperties_question,
    result: Omit<SecurityPropertiesOfHttpRequest, "serviceMethodName">
}

/**
 * Question from the websocket connection
 */
export type GetCookieSession_question = {
    serverSocketConnectionId: string
    forceInitialize: boolean;
}

export type GetCookieSession_answer = {
    question: GetCookieSession_question,
    /**
     * Can be undefined, if no session was started yet
     */
    cookieSession?: CookieSession
}

/**
 * Update the cookie session on the http side
 */
export type CookieSessionUpdate = {
    /**
     * Where did this come from ?
     */
    serverSessionClassId: string,

    newSession: CookieSession
}

/**
 * The content is encrypted and can only be read by this server, or another server that shares {@link Server#secret}
 * <p>
 * Encrypted (+MAC'ed) value in a box that points to the correct secret key that should be used to decrypt it.
 * </p>
 * - The box was encrypted by the server and it's authenticity can be trusted. It's meant to be decrypted by the server again / the client can't see the content.
 * - It stores a content type to prevent spoofing with a token on stock with a different types
 *
 */
export type ServerPrivateBox<Content> = {
    /**
     * Base64 encoded.
     * <p>
     *     <i>NOTE: Is a nonce really needed or could we save us these 24 bytes here? It won't prevent replay attacks, if handed to the client (restfuncs is aware of replay and takse other measures against these).
     *     Also data variety is enough by the current use cases (i.e. there's the ServerSocketConnection id included) and the information that 2 tokens have the same value does not hurt.
     *     But for cryptographic cleanliness we leave it in.
     *     </i>
     * </p>
     */
    nonce: string

    /**
     * Encrypted content, base64 encoded
     */
    content: string;

    /**
     * Fake property. To make ServerPrivateBox typesafe, we must reference 'Content' somewhere. Will never be set
     */
    _contentType?: Content
}