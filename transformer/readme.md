Enhances your classes with [typescript-rtti](), to make them usable with [restfuncs-server](https://www.npmjs.com/package/restfuncs-server). 
Meaning Restfuncs is able to validate the arguments to your remote methods at runtime.
## Usage
[Here's how to use it](https://github.com/bogeeee/restfuncs#setting-up-the-build-the-annoying-stuff-)


## How it works
In the first stage, this transformer, scans for all `@remote` methods and, at the bottom of inside their class, it adds the following code (here for "myMethod"): 
````typescript

/**
 * Code is generated by the restfuncs-transformer during compile-time
 */
static getRemoteMethodsMeta(): (typeof this.type_remoteMethodsMeta) {
    this.__hello_developer__make_sure_your_class_is_a_subclass_of_ServerSession // Give a friendly error message when this is not the case. Otherwise the following statement "const typia = ..." would fail and leaves the user wondering.
    let typia = this.typiaRuntime; // We need a "typia" defined in the scope, but let restfuncs manage where that dependency comes from
    return {
        transformerVersion: {major: XX,  feature: XX },
        instanceMethods: {
            "myMethod": {
                arguments: {
                    validate: (args: unknown) => typia.validate<Parameters<typeof this.prototype["myMethod"]>>(args)
                },
                result: {
                    //TODO
                },
                jsDoc: {
                    comment: "text with <strong>markup</strong>", 
                    params: {a: "text..."},
                    tags: [{name:"returns", comment: "text..."}]
                }
            }
        }
    }
}
````

In the next stage, the TYPIA transformer will replace all
`typia.validate<T>` expressions with the actual validation code body. Typia calls this "ahead of time validation"