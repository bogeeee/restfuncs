# restfuncs-transformer
This transformer prepares `ServerSession` subclasses for Typia and adds jsDoc info for the (upcoming) API browser.

## Usage
[Here's how to use it](https://github.com/bogeeee/restfuncs/tree/3.x/readme.md#setting-up-the-build-here-it-gets-a-bit-nasty-)

## Debugging parameters
Insert these into the `{ "transform": "restfuncs-transformer", ...}` block.
- debug: Set to true to dump the output of transformed **and affected** files each into a file named ...after_restfuncs-transformer.tmp
- pretty: Pretty print the output (normally it is squeezed into one line to preserve line numbers and keep source maps intact)


## How the transformer chain works
Here is, how the restfuncs-transformer, typia transformer and typescript-rtti work together: 
1. The `restfuncs-transformer` scans for all `@remote` methods and, at the bottom of inside their class, it adds the following code (here for):
````typescript
@remote
async myMethod(param1: string, someCallbackFn: (p:number) => Promise<string>);
````

results in adding this to the class body:

````typescript

/**
 * Code is generated by the restfuncs-transformer during compile-time
 */
static getRemoteMethodsMeta(): (typeof this.type_remoteMethodsMeta) {
    this.__hello_developer__make_sure_your_class_is_a_subclass_of_ServerSession // Give a friendly error message when this is not the case. Otherwise the following statement "const typia = ..." would fail and leaves the user wondering.
    let typia = this.typiaRuntime; // We need a "typia" defined in the scope, but let restfuncs manage where that dependency comes from
    const result= {
        transformerVersion: {major: XX,  feature: XX },
        instanceMethods: {
            "myMethod": {
                arguments: {
                    validateEquals: (args: unknown) => typia.validateEquals<[param1: string, someCallback: "_callback"]>(args), // Note: Can be 
                    validatePrune: ...
                },                
                result: {
                    validateEquals: (value: unknown) => typia.validateEquals<Awaited<ReturnType<typeof this.prototype["myMethod"]>>>(value),
                    ...
                },
                callbacks: [{ // here for the `someCallbackFn: (p:number) => Promise<string>` declaration
                    arguments: {
                        validateEquals: (args: unknown) => typia.validateEquals<[p: number]>(args),
                        validatePrune: ...
                    },
                    awaitedResult: {
                        validateEquals: (value: unknown) => typia.validateEquals<string>(value),
                        ...
                    }
                }],
                jsDoc: {
                    comment: "text with <strong>markup</strong>", 
                    params: {a: "text..."},
                    tags: [{name:"returns", comment: "text..."}]
                }
            }
        }
    };
    
    return result; // Code style note for this line: Why not do `return {...}` directly ? This tiny difference allows for extra properties which ensure backward compatibility with older "restfuncs-server" packages.
}
````

2. The [Typia transformer](https://typia.io/) will then replace all `typia.validate<T>` expressions with the actual validation code body. Typia calls this "ahead of time validation". At runtime this is used to validate evil input and serialize/deserialize from json/protobuf in an ultra fast way (future).
3. The [typescript-rtti transformer](https://typescript-rtti.org/) adds type-info decorations for all compiled symbols (that's all this `__RÎ¦` stuff in the .js). At runtime, this allows restfuncs to easily navigate through- and inspect all the type hierarchy. I.e when mapping REST parameter names to the remote methods arguments, for better error diagnosis, or for the upcoming API browser.